http://www.tech-archive.net/Archive/Development/microsoft.public.win32.programmer.ui/2006-01/msg00103.html


BOOL CMyDialog::OnEraseBkgnd(CDC* pDC)
{
    if (CDialog::OnEraseBkgnd(pDC))
    {
        // draw size grip
        CRect r;
        GetClientRect(&r);
        int size = GetSystemMetrics(SM_CXVSCROLL);
        r.left = r.right - size;
        r.top = r.bottom - size;
        pDC->DrawFrameControl(&r, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

LRESULT CMyDialog::OnNcHitTest(CPoint point)
{
    // return HTBOTTOMRIGHT for sizegrip area
    CRect r;
    GetClientRect(&r);
    int size = GetSystemMetrics(SM_CXVSCROLL);
    r.left = r.right - size;
    r.top = r.bottom - size;
    ScreenToClient(&point);

    if (r.PtInRect(point))
    {
        return HTBOTTOMRIGHT;
    }
    else
        return CDialog::OnNcHitTest(point);
}

// WM_SIZING

void CMyDlg::OnSizing(UINT fwSide, LPRECT pRect)
{
	CDialog::OnSizing(fwSide, pRect);

	// invalidate an area currently (before resizing) occupied
	// by size grip

	CRect r;
	GetClientRect( & r);
	int size = GetSystemMetrics(SM_CXVSCROLL);
	r.left = r.right - size;
	r.top = r.bottom - size;
	InvalidateRect( & r, FALSE); // do not erase background now

	// invalidate an area which will be (after resizing)
	// occupied by size grip

	r = * pRect;
	r.left = r.right - size;
	r.top = r.bottom - size;
	InvalidateRect( & r, FALSE);
} 